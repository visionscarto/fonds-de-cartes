<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <style>
        body {
            background: transparent;
        }
    </style>
</head>
<title>Fonds de carte visionscarto</title>

<body>

    <svg version="1.1"
    	xmlns="http://www.w3.org/2000/svg"
    	xmlns:xlink="http://www.w3.org/1999/xlink"
    	xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
    >
        <defs>
            <style type="text/css">
                .country {
                    fill: white;
                }
                .coast {
                    fill: none;
                    stroke: #555555;
                    stroke-width: 0.2mm;
                    stroke-linecap: round;
                }
                .borders {
                    fill: none;
                    stroke: #555555;
                    stroke-width: 0.15mm;
                    stroke-linecap: round;
                }
                .continents {
                    fill: #eeeeee;
                }
                .sphere, .sphere2 {
                    fill: none;
                    stroke: #999999;
                    stroke-width: 0.30mm;
                }
                .graticule {
                    fill: none;
                    stroke: #999999;
                    stroke-width: 0.05mm;
                }
                .land {
                    fill: #999999;
                }
                .capital {
                    stroke: #000000;
                    stroke-width: 0.15mm;
                    fill: white;
                }
                .country-island {
                    stroke: #555555;
                    stroke-width: 0.2mm;
                    fill: #b47a2c;
                }
                .population {
                    stroke: #ffffff;
                    stroke-width: 0.14mm;
                    fill: red;
                    fill-opacity: 0.3;
                }
                .gdp {
                    stroke: #ffffff;
                    stroke-width: 0.14mm;
                    fill: blue;
                    fill-opacity: 0.3;
                }
                .background {
                    fill: none;
                }
                #capitals {
                    display: none;
                }
                #island-nations {
                    display: none;
                }
                #gdp {
                    display: none;
                }
                #population {
                    display: none;
                }
                .frame {
                    fill: none;
                    stroke: #444444;
                    stroke-width: 0.2mm;
                    stroke-linecap: round;
                }
            </style>
        </defs>
    </svg>

    <script src="./lib/d3.v4.min.js"></script>
    <script src="./lib/d3-geo-projection.v2.min.js"></script>
    <script src="./lib/topojson.v2.min.js"></script>
    <script src="./lib/d3.geo.projection.visionscarto.js"></script>

    <script>
        function param(x, def) {
            var re = new RegExp('[?](.*&)*' + x + '=([^&]*)'),
                m = window.location.href.match(re);
            if (m) {
                return m[2];
            }
            return def;
        }

        var topo = 'data/countries_110m_mar-sah.topo.json',
            projection = null,
            laius_projection = '',
            pj = param('projection', 'robinson'),
            rotate = [+param('rotate', -10.23)],
            show_graticule = param('graticule', false),
            show_ata = param('antarctica', false),
            clipPath = param('clip') ? 'url(#clip)' : null;

        switch (pj) {
        case 'bertin1953':
            projection = d3.geoBertin1953()
                .scale(169)
                .translate([300, 236]);
            laius_projection = 'Projection créée par Philippe Rivière d’après Jacques Bertin (1953).';
            break;
        case 'equirectangular':
            projection = d3.geoEquirectangular()
                .scale(110)
                .translate([348, 475/2])
                .rotate(rotate);
            laius_projection = 'Projection plate carrée (équirectangulaire), attribuée à Marinus de Tyr (100 ap. JC).';
            break;
        case 'northpole':
            projection = d3.geoAzimuthalEqualArea()
                .scale(354)
                .translate([350, 240])
                .rotate([0, -90, 112])
                .clipExtent([[2,2], [693, 471]]);
            laius_projection = 'Projection azimutale équivalente.';
            break;
        case 'southpole':
            projection = d3.geoAzimuthalEqualArea()
                .scale(354)
                .translate([350, 240])
                .rotate([0, 90, 222])
                .clipExtent([[2,2], [693, 471]]);
            laius_projection = 'Projection azimutale équivalente.';
            break;
        case 'robinson':
            projection = d3.geoRobinson()
                .translate([324, 245])
                .scale(128)
                .rotate(rotate);
            laius_projection = 'Projection d’Arthur H. Robinson (1963).';
            break;
        case 'larrivee':
            projection = d3.geoLarrivee()
                .translate([335, 255])
                .scale(121)
                .rotate(rotate);
            laius_projection = 'Projection de Léo Larrivée (1988).';
            break;
        case 'bottomley':
            projection = d3.geoBottomley()
                .translate([287, 265])
                .scale(152)
                .rotate(rotate);
            laius_projection = 'Projection d’Henry Bottomley (2003).';
            break;
        case 'winkel-tripel':
            projection = d3.geoWinkel3()
                .translate([314, 250])
                .scale(160)
                .rotate(rotate);
            laius_projection = 'Projection d’Oswald Winkel, dite Winkel-Tripel (1921).';
            break;
        case 'gallpeters':
            projection = d3.geoCylindricalEqualArea()
                .parallel(45)
                .translate([348, 240])
                .scale(154)
                .rotate(rotate);
            laius_projection = 'Projection de James Gall (1855), popularisée par Arno Peters.';
            break;
        case 'gingery':
            projection = d3.geoGingery()
                .rotate(rotate)
                .fitExtent([[2,2], [693, 471]], {type:"Sphere"});
            laius_projection = 'Projection créée par Jason Davies, d’après Walter Gingery (1944).';
            break;
        case 'waterman':
            projection = d3.geoPolyhedronWaterman()
                .rotate([25, -2])
                .scale(118)
                .translate([200, 200]);
            laius_projection = 'Projection de Waterman.';
            break;
        case 'timesus':
            projection = d3.geoTimes()
                .rotate([117,-5])
                .scale(151)
                .translate([347, 257]);
            laius_projection = 'Projection “Times” centrée sur les États-Unis.';
            break;
        default:
        	pj = 'geo' + pj.replace(/^geo/, '');
            if (pj in d3) {
                projection = d3[pj]();
                projection
                	.fitExtent([[2,2], [693, 471]], {type:"Sphere"});
                laius_projection = 'Projection : ' + pj.replace(/^geo/, '') + '.';
            } else {
                alert('projection ' + pj + ' inconnue');
                projection = null;
            }
            break;
        }

        if (projection.rotate && projection.rotate()+'' == [0,0,0]+'')
            projection.rotate(rotate);

        if (projection && projection.precision) projection.precision(0.001);

        var laius = [
          laius_projection,
          'Contours : Natural Earth, modifiés Visionscarto. Logiciel : D3.js',
          'Gratuit et libre pour tous usages.',
          'Nous aimons les cartes, partageons-les !  contact@visionscarto.net'
        ];

        var width = 700,
            height = 475;

        var path = d3.geoPath()
            .projection(projection);

        var svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height)
            .call(svglayer, 'base map');

		var defs = svg.select('defs');

		if (!show_ata) {
			defs.select('style')
			.text(defs.select('style').text() + "\n\n#countries .ATA, #countries .ATF { display: none; } #Antarctica { display: none; stroke: #555; stroke-width: 0.2mm; stroke-linecap: round; }");
			is_antarctica = function (d) {
	            if (!d.properties) return false;
	            return ['ATA', 'ATF'].indexOf(d.properties.iso_a3) > -1;
	        };
		} else {
	        is_antarctica = function(d) { return false; };
		}

		defs.append("path")
            .datum({type: "Sphere"})
            .attr("id", "sphere")
            .attr("d", path);

        if (clipPath) defs.append("clipPath")
            .attr("id", "clip")
            .append("use")
            .attr("xlink:href", "#sphere");


        var bg = svg
        	.append('g')
            .call(svglayer, 'background')
            .append('rect')
            .attr('class', 'background')
            .attr('x', 2)
            .attr('y', 2)
            .attr('width', width - 8)
            .attr('height', height - 5);

        var world = svg.append('g')
            .call(svglayer, 'world');

        graphsignature([' ', ' ', ' '], ['Visionscarto', '2017'], laius);

        d3.queue()
            .defer(d3.json, topo)
            .defer(d3.csv, './data/capitals.csv')
            .defer(d3.csv, './data/island-nations.csv')
            .defer(d3.json, '../some-geo-data/population-centroids.geojson')
            .await(function (error, wjson, capitals, islands, pop) {

                if (error) throw error;

                var countries = wjson.objects.countries;
                countries.geometries = countries.geometries
                    .sort(function (a, b) {
                        if (!a.properties) return 0;
                        return d3.descending(
                            class_iso_a3(a.properties),
                            class_iso_a3(b.properties)
                        );
                    });

                var globe = world.append('g')
                    .call(svglayer, 'globe')
                    .attr('class', 'globe')
                    .style('display', show_graticule ? null : 'none');

                globe.append('g')
                    .attr('class', 'land')
                    .call(svglayer, 'land')
                    .append('path')
                    .attr('class', 'land')
                    .attr('clip-path', clipPath)
                    .datum(topojson.merge(wjson, wjson.objects.countries.geometries
                        .filter(function(d) { return !is_antarctica(d); })
                    ))
                    .attr('d', path);

                globe.append('g')
                    .attr('class', 'graticule')
                    .call(svglayer, 'graticule')
                    .append('path')
                    .attr('class', 'graticule')
                    .attr('clip-path', clipPath)
                    .datum(d3.geoGraticule())
                    .attr('d', path);

                globe.append('use')
                    .attr('class', 'sphere')
                    .call(svglayer, 'sphere')
                    .attr("xlink:href", "#sphere");

                world.append('g')
                    .attr('class', 'continents')
                    .call(svglayer, 'continents')
                    .selectAll('.continent')
                    .data(
                        d3.set(countries.geometries.map(function (d) {
                            return d.properties && d.properties.continent;
                        }))
                        .values()
                )
                    .enter()
                    .append('g')
                    .attr('class', 'continent')
                    .attr('clip-path', clipPath)
                    .call(svglayer, function (d) {
                            return d;
                        })
                    .append('path')
                    .attr('d', function (d) {
                            return path(
                                topojson.merge(wjson,
                                    countries.geometries
                                    .filter(function (e) {
                                        return !e.properties || e.properties.continent == d;
                                    })
                                )
                            );
                        });

                var randomcolor = d3.scaleOrdinal(d3.schemeCategory20b);
                world.append('g')
                    .attr('clip-path', clipPath)
                    .call(svglayer, 'countries')
                    .selectAll('.country')
                    .data(topojson.feature(wjson, countries).features)
                    .enter()
                    .append('g')
                    .attr('class', function (d) {
                        return 'country ' + class_iso_a3(d.properties);
                    })
                    .call(svglayer, function (d) {
                        return class_iso_a3(d.properties) + ' ' + d.properties.name;
                    })
                    .append('path')
                    .attr("d", path);

                world.append('g')
                    .call(svglayer, 'borders')
                    .append('path')
                    .attr('class', 'borders')
                    .datum(topojson.mesh(wjson, countries, function (a, b) {
                        return a !== b;
                    }))
                    .attr('d', path)
                    .attr('clip-path', clipPath);


                countries.geometries = countries.geometries.filter(function(d) {
                    return !is_antarctica(d);
                });

                world.append('g')
                    .call(svglayer, 'coast')
                    .append('path')
                    .datum(topojson.mesh(wjson, countries, function (a, b) {
                        return a == b;
                    }))
                    .attr('d', path)
                    .attr('class', 'coast')
                    .attr('clip-path', clipPath);

                world.append('g')
                    .call(svglayer, 'sphere2')
                    .style('display', show_graticule ? null : 'none')
                    .append('path')
                    .attr('class', 'sphere2')
                    .datum({type:"Sphere"})
                    .attr('d', path);


                // ISLAND NATIONS
                var isl = world.append('g')
                    .call(svglayer, 'island-nations');

                isl.selectAll('circle')
                    .data(
                        islands.map(function (d) {
                            var p = projection([parseFloat(d.lon), parseFloat(d.lat)]);
                            if (p) {
                                d.x = p[0];
                                d.y = p[1];
                            }
                            return d;
                        })
                        .sort(function (a, b) {
                            return d3.descending(a.id, b.id);
                        })
                )
                    .enter()
                    .append('circle')
                    .call(svglayer, function (d) {
                            return d.id + ' ' + d.name;
                        })
                    .attr('cx', function (d) {
                            return d.x;
                        })
                    .attr('cy', function (d) {
                            return d.y;
                        })
                    .attr('class', function (d) {
                            return d.id + ' ' + 'country-island';
                        })
                    .attr('r', '0.25mm');


                // CAPITALS
                var cap = world.append('g')
                    .call(svglayer, 'capitals');

                cap.selectAll('rect')
                    .data(
                        capitals.map(function (d) {
                            var p = projection([parseFloat(d.lon), parseFloat(d.lat)]);
                            if (p) {
                                d.x = p[0];
                                d.y = p[1];
                            }
                            return d;
                        })
                        .sort(function (a, b) {
                            return d3.descending(a.id, b.id);
                        })
                )
                    .enter()
                    .append('g')
                    .call(svglayer, function (d) {
                            return d.id + ' ' + d.capital;
                        })
                    .attr('class', function (d) {
                            return 'capital ' + d.id;
                        })
                    .attr('transform', function (d) {
                            return 'translate(' + d.x + ',' + d.y + ')';
                    })
                    .append('rect')
                    .attr('width', '0.4mm')
                    .attr('height', '0.4mm')
                    .attr('transform', 'translate(-0.5, -0.5)');


                // POPULATION
                var data = pop
                    .features
                    .map(function (d) {
                        d.xy = projection(d.geometry.coordinates)
                        d.pop = parseFloat(d.properties.POP_EST);
                        return d;
                    })
                    .filter(function (d) {
                        return (d.properties.GU_A3 !== -99) && d.pop > 0;
                    })
                    .sort(function (a, b) {
                        return d3.descending(a.pop, b.pop);
                    })

                var pop_scale = d3.scaleSqrt()
                    .domain([0, d3.max(data, function (d) {
                        return d.pop;
                    })])
                    .range([1, 23]);

                world.append('g')
                    .call(svglayer, 'population')
                    .selectAll('circle')
                    .data(data)
                    .enter()
                    .append('circle')
                    .attr('class', function (d) {
                        return 'population ' + (d.properties.GU_A3);
                    })
                    .attr('data-population', function (d) {
                        return d.pop;
                    })
                    .attr('cx', function (d) {
                            return d.xy[0];
                        })
                    .attr('cy', function (d) {
                            return d.xy[1];
                        })
                    .attr('r', function (d) {
                            return pop_scale(d.pop);
                        })
                    .call(svglayer, function (d) {
                        return d.properties.GU_A3 + ' ' + d.properties.NAME;
                    });


                // GDP/PIB
                var data = pop
                    .features
                    .map(function (d) {
                        d.xy = projection(d.geometry.coordinates)
                        d.gdp = parseFloat(d.properties.GDP_MD_EST);
                        return d;
                    })
                    .filter(function (d) {
                        return (d.properties.GU_A3 !== -99) && d.gdp > 0;
                    })
                    .sort(function (a, b) {
                        return d3.descending(a.gdp, b.gdp);
                    })

                var gdp_scale = d3.scaleSqrt()
                    .domain([0, d3.max(data, function (d) {
                        return d.gdp;
                    })])
                    .range([1, 23]);

                world.append('g')
                    .call(svglayer, 'gdp')
                    .selectAll('rect')
                    .data(data)
                    .enter()
                    .append('rect')
                    .attr('class', function (d) {
                        return 'gdp ' + (d.properties.GU_A3);
                    })
                    .attr('data-gdp', function (d) {
                        return d.gdp;
                    })
                    .attr('x', function (d) {
                            return d.xy[0];
                        })
                    .attr('y', function (d) {
                            return d.xy[1];
                        })
                    .attr('width', function (d) {
                            return gdp_scale(d.gdp);
                        })
                    .attr('height', function (d) {
                            return gdp_scale(d.gdp);
                        })
                    .attr('transform', function (d) {
                            var x = -gdp_scale(d.gdp) / 2;
                            return 'translate(' + x + ',' + x + ')';
                        })
                    .call(svglayer, function (d) {
                        return d.properties.GU_A3 + ' ' + d.properties.NAME;
                    });
            });


        function class_iso_a3(prop) {
            return (prop.iso_a3 != '-99') ? prop.iso_a3 : prop.sov_a3;
        }

        function graphsignature(titre, lignes, laius) {
            var sig = svg
                .append('g')
                .call(svglayer, 'signature');

            sig.append('g')
                .call(svglayer, 'frame')
                .append('rect')
                .attr('class', 'frame')
                .attr('x', 2)
                .attr('y', 2)
                .attr('width', width - 8)
                .attr('height', height - 5);

            var gtitre = sig.append('g').call(svglayer, 'title');
            var size = 36;
            gtitre
                .selectAll('text')
                .data(titre)
                .enter()
                .append('text')
                .attr('y', function (d, i) {
                        return (size + 4) * i;
                    })
                .attr('transform', 'translate(' + [width - 14, size] + ')')
                .attr('fill', 'black')
                .attr('text-anchor', 'end')
                .style("font-size", size + 'px')
                .text(function (d) {
                    return d;
                });

            var gsignature = sig.append('g').call(svglayer, lignes[0]);

            gsignature
                .selectAll('text')
                .data(lignes)
                .enter()
                .append('text')
                .attr("y", function (d, i) {
                    return 14 * i;
                })
                .attr("fill", "black")
                .attr("text-anchor", "middle")
                .style("font-size", "8px")
                .text(function (d) {
                    return d.toUpperCase();
                });

            var bbox = gsignature.node().getBBox();
            gsignature
                .attr('transform', 'translate(' + [width - bbox.width / 2 - 14, height - bbox.height - 2] + ')');


            gsignature
                .selectAll('line')
                .data(lignes.slice(1))
                .enter()
                .append('line')
                .attr('x1', -bbox.width / 2)
                .attr('x2', bbox.width / 2)
                .attr('y1', function (d, i) {
                        return 14 * i + 4;
                    })
                .attr('y2', function (d, i) {
                        return 14 * i + 4;
                    })
                .attr("stroke", "black");

            if (laius) {
                glaius = sig.append('text')
                    .call(svglayer, 'presentation');
                glaius
                    .selectAll('tspan')
                    .data(laius)
                    .enter()
                    .append('tspan')
                    .attr('x', 0)
                    .attr('y', function (d, i) {
                        return 10 * i;
                    })
                    .attr("fill", "black")
                    .attr("text-anchor", "start")
                    .style("font-size", "8px")
                    .text(function (d) {
                        return d;
                    });

                var bbox = glaius.node().getBBox();
                glaius
                    .attr('transform', 'translate(' + [12, height - bbox.height - 4] + ')');

            }

        }

	// cf. https://github.com/d3/d3/issues/291#issuecomment-226988829
	function svglayer(sel, id) {
		return sel
			.attr('id', id)
			.attr(':inkscape:groupmode', 'layer')
			.attr(':inkscape:label', id);
	}

    </script>
